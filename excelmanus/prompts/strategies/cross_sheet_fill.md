---
name: cross_sheet_fill
version: "1.0.0"
priority: 50
layer: strategy
max_tokens: 300
conditions:
  sheet_count_gte: 2
  write_hint: "may_write"
---
## 跨 Sheet 数据填充策略

当需要从一个 Sheet 查找数据填入另一个 Sheet 时：

1. **确认完整数据范围**：用 list_sheets 确认源表和目标表的总行数，写入必须覆盖目标表的全部数据行，不能只处理前几十行。

2. **使用 `run_code`**：跨表匹配填充是 `run_code` 的典型场景。用 pandas 读取源表和目标表，通过 merge/map 完成匹配计算，一次性写入结果。

3. **优先写值而非公式**：openpyxl 写入的公式没有缓存计算值，外部读取会显示为空。应在 Python 层面完成匹配计算，写入具体值。

4. **匹配逻辑验证**：写入前先对少量行（如前 5 行）做匹配验证，确认键列、结果列的对应关系正确后再批量写入。

5. **写入后抽查**：批量写入完成后，用 read_excel 读取目标区域的前几行和末几行，确认值已正确写入。

### 常见匹配场景
- **一对一查找**：目标表每行通过键列（如 ID、名称）在源表中查找对应行，提取结果列。类似 VLOOKUP。
- **聚合填充**：目标表每行对应源表中多行数据的聚合结果（如求和、计数、平均值）。需要先按键分组聚合再写入。
- **位置映射**：目标表某列的值对应源表中的列位置索引（如"第 1 名在 J 列、第 2 名在 K 列"）。需要理解位置关系而非简单值匹配。

### 常见陷阱
- 源表和目标表的键列可能有前后空格差异，匹配前需 strip。
- 源表可能有重复键，需明确取第一条还是聚合。
- 目标表的待填充范围可能远大于 read_excel 的默认预览行数——必须从 list_sheets 获取总行数。
